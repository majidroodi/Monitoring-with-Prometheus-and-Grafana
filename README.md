# Monitoring With Prometheus and Grafana

![Screenshot](images/Roadmap.png)

üìå Roadmap

![Screenshot](images/p&g.png)




üëÅÔ∏è Monitoring

Monitoring is about exposing metrics, automating data collection and alerting pipelines, and ensuring incidents are detected and reported with zero manual effort.

Types of Monitoring

Alerting: Notifies the team when metrics cross defined thresholds or abnormal behavior is detected.

Debugging: Focuses on finding the root cause of failures by analyzing logs, traces, and metrics.

Trending: Identifies long-term patterns by analyzing historical metrics to predict capacity or performance needs.

Plumbing: Checks the health of the underlying infrastructure such as CPU, memory, disk, network, and service availability.

Comparing: Monitors system behavior before and after a deployment, upgrade, or configuration change to detect regressions.

Challenges in Monitoring

Too many metrics

Alert fatigue

Lack of context (metrics without logs/traces)

Microservice complexity

Distributed data collection

Long-term storage & cost

Unknown problems not covered by metrics

üí• Observability

In the world of IT and Cloud Computing, Observability is the ability to understand the internal state of a system based on the data it produces ‚Äî such as logs, metrics, and traces.

Observability allows us to gain insight, understand what is happening now, and even predict what will happen next. With a strong observability stack, we can analyze issues, detect anomalies, and prevent future failures.

Key Components of Observability

Symptom:
The observable effect of a problem in the system. Symptoms are what users or monitoring tools notice.

Cause:
The underlying reason why the symptom occurs. Causes are hidden and require analysis of metrics, logs, and traces to identify.

Examples:

Symptom	Cause
Website is loading slowly	Database queries are taking too long due to missing indexes
API service is not responding	Downstream service is down or experiencing timeouts
500 errors in web server logs	Backend code error during request processing
Increased latency in response time	High CPU load or insufficient memory on the server
High number of user errors	Misconfigured load balancer or recent changes in service configuration
Whitebox vs Blackbox Monitoring

Whitebox Monitoring: Observing internal metrics of the system, such as CPU, memory, logs, and application-level metrics. The system‚Äôs internal state is exposed for monitoring.

Blackbox Monitoring: Observing the system from the outside, as a user or client would see it, without access to internal metrics. Typically checks service availability, response times, and endpoint health.

‚úÖ The Four Golden Signals

Latency: Time taken to process a request (average or percentile).

Traffic: Amount of demand on the system (requests per second, jobs, messages).

Errors: Rate of failed requests or exceptions.

Saturation: How ‚Äúfull‚Äù or busy the service is (CPU, memory, disk, queue length).

‚úÖ Event

An event is any observable occurrence in a system that may be significant for monitoring, alerting, or troubleshooting. Events can be generated by the system itself, users, or external services.

Examples of events:

A server starts or stops

A service crashes

A configuration change is applied

A high error rate is detected

An alert is triggered

Profiling

Profiling is the process of measuring detailed resource usage by a program, often at the code or function level, to identify slow spots, CPU/memory heavy areas, or memory leaks.

Traces

Tracing tracks a request or transaction through the system in detail, sometimes even at the code level, to understand how services interact to provide a response. Tracing helps to see what happens inside the system from request to response.

Logs

Logs are textual records of events that occur in the system over time. They can be structured or unstructured. Logs should be collected and retained from all environments. Filtering noise and proper categorization are essential.

Metrics

Metrics are numeric data calculated or aggregated over a period of time and visualized. Metrics can come from various sources, such as infrastructure, hosts, internal/external services, or cloud platforms. Metrics are exactly what we monitor in our systems.

Data Sources

Network flow data

Virtual servers: VC Logs, ESXi Logs, etc.

Cloud services: AWS EC2, EMR, S3, etc.

Docker: Logging driver, syslog, app logs

Containers & MSAs: Container/microservices logs, metrics, events

Third-party services: SaaS, FaaS, Serverless

Control systems: vCenter, Swarm, Kubernetes

Dev automation: Jenkins, SonarQube

Infra orchestration: Chef, Puppet, Ansible

Signals for security analytics: DLP, device telemetry, metadata

Signals from mobile devices: Product adoption, feature usage

Metrics for business analytics: App data, HTTP events, SFA/CRM

Signals from social analytics: Tweets, sentiment over time

Customer experience analytics: App logs, call records, business process logs

Analytics for service intelligence: ER visits, wait times, prescriptions

Message buses and middleware
